#  操作系统面试题整理

## 1.进程， 线程及程序三者有什么区别

1.程序是是编译好的可执行的二进制文件

2.进程是程序在内存中的镜像， 他是一个实例

- 进程包括加载的二进制程序
-  虚拟内存
  * 内核资源
  * 打开的文件
-  关联用户
  * 哪一个应用程序是由哪一个用户关联起来的会在这里显示出来

3.线程是资源调度的最小单位

- 是进程的执行单元
- 同样也是操作系统可以调度的最小单元

4.进程和线程相同

- 增加程序的并发度

5.进程和线程有什么不同

* 进程中有一个虚拟内存
  * 独享内存空间
    * 通信较为复杂
* 线程由一个虚拟处理器
  * 独享CPU
  * 共享整个进程空间的内容
    * 线程通信较为简单
    * 线程调度代价较小
      * 内存空间较小
      * CPU消耗较小

6.选择进程和线程各有什么优势

* 多进程适合并发度较小的因为较为稳定
  * 做自己各自无相关的任务
  * 守护进程来用多进程
* 多线程为什么要用
  * 因为会让编程比较简单
  * 他的通信较为简单

7.进程和线程的缺点

* 进程的
  * 进程的通信比较复杂
  * 进程的调度比较大
* 线程的
  * 调试较为困难
  * 安全性
    * 进行资源的竞争
    * 加锁的可能会造成死锁问题

## 2.你所知道的fork()函数， 以及在多进程编程中的需要注意的事项

1.用途

* 用来在某一个进程中开启一个子进程
* 它一般是在进行写的过程中产生

2.函数原型

* 没有参数

3.返回值

* 由多个返回值0，-1
  * 在子进程中返回的是0， 在父进程中返回的是pid，
    * 所以所在父进程中想要获得子进程字有这一种方法, 返回值
      * 因为fork后， 子进程音竟是一个独立的空间了， 父进程失去对它的控制权
    * 但是在子进程中想要获得自己的pid使用getpid(),获得父进程的pid是用getppid();
  * 返回值的-1
    * 资源不够
    * 打开的子进程过多（1024默认）

4.问题

* 没有进行是否是父进程的pid的进程判断， 那么在进行第一次循环之后， 父子进程都会进行fork(), 所以第二次就是四个进程
* 还有可能是将输出缓冲区的内容拷贝一份
  * 就是在fork值前输出一段话， 没有进行回车，fork之后就会输出两遍
    * 系统输出一般都是按行输出，  没有输入换行之后， 它就会等待一行满了之后在进行输出
* 僵尸进程
  * 孩子先于父进程死亡， 父进程没有进行收尸， 就是将时候僵尸进程
  * 占据pid
* 孤儿进程
  * 父进程死亡
  * 对于系统危害不大， 因为会有（init）1号进程收养
  * 有好处， 父进程在创建一个子进程之后死亡， 不妨碍子进程的发展， 这就是守护进程的实现方式

### 3.进程有哪些状态， 他们是如何切换的

* 三态模型
  * 就绪
  * 运行
    * 他和就绪可以相互转换
    * 进程调度器来控制进程的执行
    * 调度器给的时间便用完之后没有结束会进入到就绪状态， 需要给别的进程话语权
  * 阻塞
    * 运行到阻塞一般都是io阻塞
    * 拿到数据之后会进入就绪状态

### 4.请你对用户态， 内核态以及系统调用三个概念作出解释。

1.背景知识

* 特权及
  * 对于x86架构的CPU硬件上有0-3四个特权级别
    * 特权指令数字越小级别越高
    * 非特权指令
  * 在Unix/Linux系统上， 只使用了0和3特权级
    * 3是用户级别， 它是由内核提供响应支持

2.两者差别

* 用户态
  * 又称为目态
  * 上层应用程序的活动空间
* 内核态
  * 称为管态、核心态
  * 控制计算机硬件资源， 为上层用户程序提供环境
* 特权不同
  * 在用户态状态下CPU可能被抢占， 内核带不允许

3.相互切换

* 由用户切换到内核态
  * 中断
    * 外部中断
      * 外部设备的中断
  * 异常
    * 算术溢出
    * 内存溢出
  * 系统调用（陷入）
    * 主动通过系统调用到内核态，
* 内核态到用户态
  * 设置系统状态字

4.系统调用

* 为了使上层应用能够访问到硬件资源 ， 内核为上层应用提供的接口
* 是用户态进程主动要求切换到内核态的一种方式， 用户态进程通过系统调用申请使用操作完成工作（它是为一的主动方式）
* 包括
  * 进程控制
  * 进程通信
  * 文件操作
  * 设备操作等

### 5.线程同步是干什么的， 有哪些机制。

1.干什么的

* 当使用多个线程来访问同一个数据时，非常容易出现线程安全问题所以我们用同步机制来解决这些问题。对于正在执行的线程， 其他不可以进行干扰。
* 主要手段是互斥

1、相关名词

* 临界区
  * 通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问
* 互斥对象
  * 只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问
* 信号量
  * 它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目

4.事件对象

* 通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作



## 3.内核线程和用户线程有什么区别。 

1.分类原则

* 根据操作系统是否能感知到线程的存在来进行分类
  * 用户线程
    * 感知不到的
  * 内核线程
    * 感知的到

2，优缺点对比

* 用户线程优点
  * 可以在不支持多线程的机器上实现
  * 在自己的线程空间自己调度销毁
  * 操作相对灵活


* 缺点
  * 内核不知道线程的存在， 对于内核来说， 它只是一个进程
  * 如果发生线程阻塞， 操作系统就不会调度系统里面的其他的线程
* 内核态的线程
  * 以线程为基本单位的， 由内核来调动
  * 它可以在全系统的资源使用

3.linux线程用的是什么线程

* 多线程模型
  * 多对一
  * 一对一
    * 单前linux下的主要模式
  * 多对多